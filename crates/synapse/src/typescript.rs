use anyhow::Result;
use ranvier_core::schematic::{NodeKind, Schematic};
use std::collections::BTreeSet;

pub struct TypeScriptGenerator;

impl TypeScriptGenerator {
    pub fn new() -> Self {
        Self
    }

    /// Generate complete TypeScript client for a Schematic
    pub fn generate(&self, schematic: &Schematic) -> Result<String> {
        let mut ts = String::new();

        // Header
        ts.push_str("// Generated by Ranvier Synapse\n");
        ts.push_str(&format!("// Schematic: {}\n", schematic.name));
        ts.push_str(&format!(
            "// Generated at: {}\n\n",
            chrono::Utc::now().to_rfc3339()
        ));

        // Type definitions
        ts.push_str(&self.generate_types(schematic)?);

        // Cache keys
        ts.push_str("\n");
        ts.push_str(&self.generate_cache_keys(schematic)?);

        // Query hooks
        ts.push_str("\n");
        ts.push_str(&self.generate_query_hooks(schematic)?);

        // WebSocket bindings
        ts.push_str("\n");
        ts.push_str(&self.generate_ws_bindings(schematic)?);

        Ok(ts)
    }

    /// Generate TypeScript type definitions
    pub fn generate_types(&self, schematic: &Schematic) -> Result<String> {
        let mut ts = String::new();

        ts.push_str("export namespace Schematic {\n");

        for node in &schematic.nodes {
            let safe_label = self.sanitize_identifier(&node.label);

            ts.push_str(&format!("  export namespace {} {{\n", safe_label));
            ts.push_str(&format!(
                "    export type Input = {};\n",
                self.map_type(&node.input_type)
            ));
            ts.push_str(&format!(
                "    export type Output = {};\n",
                self.map_type(&node.output_type)
            ));
            ts.push_str("  }\n\n");
        }

        ts.push_str("}\n");

        Ok(ts)
    }

    /// Generate cache key constants
    pub fn generate_cache_keys(&self, schematic: &Schematic) -> Result<String> {
        let mut ts = String::new();

        ts.push_str("// Cache keys for data fetching\n");
        ts.push_str("export const CACHE_KEYS = {\n");

        // Collect unique node labels
        let mut labels = BTreeSet::new();
        for node in &schematic.nodes {
            labels.insert(self.sanitize_identifier(&node.label));
        }

        for label in labels {
            let cache_key = format!("\"{}\"", label.to_lowercase());
            ts.push_str(&format!("  {}: {},\n", label, cache_key));
        }

        ts.push_str("} as const;\n");

        Ok(ts)
    }

    /// Generate TanStack Query / Svelte Query compatible hooks
    pub fn generate_query_hooks(&self, schematic: &Schematic) -> Result<String> {
        let mut ts = String::new();

        ts.push_str("// Query hooks (TanStack Query / Svelte Query compatible)\n\n");

        for node in &schematic.nodes {
            let safe_label = self.sanitize_identifier(&node.label);
            let hook_name = format!("use{}", to_pascal_case(&safe_label));
            let query_key = format!("CACHE_KEYS.{}", safe_label);

            ts.push_str(&format!(
                "export function {}(options?: {{ enabled?: boolean }}) {{\n",
                hook_name
            ));
            ts.push_str(&format!("  return useQuery({{\n"));
            ts.push_str(&format!("    queryKey: [{}],\n", query_key));
            ts.push_str(&format!(
                "    queryFn: () => fetch(`/api/{}').then(r => r.json()),\n",
                safe_label.to_lowercase()
            ));
            ts.push_str(&format!("    ...options,\n"));
            ts.push_str(&format!("  }});\n"));
            ts.push_str(&format!("}}\n\n"));
        }

        Ok(ts)
    }

    /// Generate WebSocket subscription bindings
    pub fn generate_ws_bindings(&self, schematic: &Schematic) -> Result<String> {
        let mut ts = String::new();

        ts.push_str("// WebSocket subscription bindings\n\n");
        ts.push_str("export type WsMessage<T> = {\n");
        ts.push_str("  type: string;\n");
        ts.push_str("  data: T;\n");
        ts.push_str("}};\n\n");

        ts.push_str("export function createWsConnection<T>(url: string) {\n");
        ts.push_str("  const ws = new WebSocket(url);\n\n");
        ts.push_str("  return {{\n");
        ts.push_str(
            "    on: (event: 'message' | 'open' | 'close', handler: (data: T) => void) => {\n",
        );
        ts.push_str("      ws.addEventListener(event, (e) => {\n");
        ts.push_str("        if (e.type === 'message') {\n");
        ts.push_str("          const msg = JSON.parse((e as MessageEvent).data);\n");
        ts.push_str("          handler(msg.data);\n");
        ts.push_str("        }} else {\n");
        ts.push_str("          handler(null as any);\n");
        ts.push_str("        }}\n");
        ts.push_str("      }});\n");
        ts.push_str("      return ws;\n");
        ts.push_str("    }},\n");
        ts.push_str("    send: (data: T) => ws.send(JSON.stringify(data)),\n");
        ts.push_str("    close: () => ws.close(),\n");
        ts.push_str("  }};\n");
        ts.push_str("}}\n\n");

        // Generate subscription functions for egress nodes
        for node in &schematic.nodes {
            if matches!(node.kind, NodeKind::Egress | NodeKind::Atom) {
                let safe_label = self.sanitize_identifier(&node.label);
                let sub_name = format!("subscribe{}", to_pascal_case(&safe_label));

                ts.push_str(&format!(
                    "export function {}(handler: (data: {}) => void) {{\n",
                    sub_name,
                    self.map_type(&node.output_type)
                ));
                ts.push_str(&format!(
                    "  return createWsConnection<Schematic.{}.Output>(`/ws/{}`);\n",
                    safe_label,
                    safe_label.to_lowercase()
                ));
                ts.push_str("}}\n\n");
            }
        }

        Ok(ts)
    }

    fn map_type(&self, rust_type: &str) -> String {
        // Basic heuristic for Rust -> TS mapping
        match rust_type {
            t if t.contains("String") || t.contains("str") => "string".to_string(),
            t if t.contains("u32")
                || t.contains("i32")
                || t.contains("u64")
                || t.contains("i64")
                || t.contains("f32")
                || t.contains("f64")
                || t.contains("usize")
                || t.contains("isize") =>
            {
                "number".to_string()
            }
            t if t.contains("bool") => "boolean".to_string(),
            "()" => "void".to_string(),
            t if t.starts_with("Option<") => {
                let inner = t.trim_start_matches("Option<").trim_end_matches(">");
                format!("{} | null", self.map_type(inner))
            }
            t if t.starts_with("Vec<") => {
                let inner = t.trim_start_matches("Vec<").trim_end_matches(">");
                format!("Array<{}>", self.map_type(inner))
            }
            t if t.contains("DateTime") => "string".to_string(), // ISO 8601
            _ => {
                // Try to extract a reasonable type name
                if let Some(name) = rust_type.split("::").last() {
                    if name.len() < 20 && name.chars().all(|c| c.is_alphanumeric() || c == '_') {
                        name.to_string()
                    } else {
                        "any".to_string()
                    }
                } else {
                    "any".to_string()
                }
            }
        }
    }

    fn sanitize_identifier(&self, label: &str) -> String {
        label
            .replace(" ", "_")
            .replace("::", "__")
            .replace("-", "_")
    }
}

/// Convert a string to PascalCase for hook/type names
fn to_pascal_case(s: &str) -> String {
    s.split('_')
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
            }
        })
        .collect()
}

// Generate query hooks only (for selective import)
impl TypeScriptGenerator {
    pub fn generate_query_hooks_only(&self, schematic: &Schematic) -> Result<String> {
        self.generate_query_hooks(schematic)
    }

    // Generate cache keys only
    pub fn generate_cache_keys_only(&self, schematic: &Schematic) -> Result<String> {
        self.generate_cache_keys(schematic)
    }
}
